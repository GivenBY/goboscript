use std::rc::Rc;
use std::str::FromStr;
use logos::Span;
use lalrpop_util::ParseError;
use crate::lexer::Token;
use crate::reporting::ParserError;
use crate::ast::*;

grammar<'input>(input: &'input str);

pub Declrs: Declrs<'input> = Declr*;

Declr: Rrc<Declr<'input>> = {
    <l:@L> "costumes" <r:@R> <p:Strings> ";" => rrc(Declr::Costumes(p, l..r)),
    <l:@L> "sounds" <r:@R> <p:Strings> ";" => rrc(Declr::Sounds(p, l..r)),
    <w:"nowarp"?> "def" <l:@L> <n:Name> <r:@R> <a:Names> <b:Stmts>
        => rrc(Declr::Def(Function{name: n, args: a, body: b, warp: w.is_none(), span: l..r})),
    <l:@L> "onflag" <r:@R> <b:Stmts> => rrc(Declr::OnFlag(b, l..r)),
    "onkey" <l:@L> <k:ParsedString> <r:@R> <b:Stmts> => rrc(Declr::OnKey(k, b, l..r)),
    <l:@L> "onclick" <r:@R> <b:Stmts> => rrc(Declr::OnClick(b, l..r)),
    "onbackdrop" <l:@L> <k:ParsedString> <r:@R> <b:Stmts> => rrc(Declr::OnBackdrop(k, b, l..r)),
    <l:@L> "onloudness" <r:@R> ">" <e:Expr> <b:Stmts> => rrc(Declr::OnLoudnessGreaterThan(e, b, l..r)),
    <l:@L> "ontimer" <r:@R> ">" <e:Expr> <b:Stmts> => rrc(Declr::OnTimerGreaterThan(e, b, l..r)),
    "on" <l:@L> <k:ParsedString> <r:@R> <b:Stmts> => rrc(Declr::OnMessage(k, b, l..r)),
    <l:@L> "onclone" <r:@R> <b:Stmts> => rrc(Declr::OnClone(b, l..r)),
}

Stmts: Stmts<'input> = "{" <Stmt*> "}";

If: Rrc<Stmt<'input>> = {
    <l:@L> "if" <r:@R> <c:Expr> <i:Stmts>
        => rrc(Stmt::Branch(c, i, vec![], l..r)),
    <l:@L> "if" <r:@R> <c:Expr> <i:Stmts> "else" <e:Stmts>
        => rrc(Stmt::Branch(c, i, e, l..r)),
    <l:@L> "if" <r:@R> <c:Expr> <i:Stmts> <e:Elif>
        => rrc(Stmt::Branch(c, i, vec![e], l..r)),
}

Elif: Rrc<Stmt<'input>> = {
    <l:@L> "elif" <r:@R> <c:Expr> <i:Stmts>
        => rrc(Stmt::Branch(c, i, vec![], l..r)),
    <l:@L> "elif" <r:@R> <c:Expr> <i:Stmts> "else" <e:Stmts>
        => rrc(Stmt::Branch(c, i, e, l..r)),
    <l:@L> "elif" <r:@R> <c:Expr> <i:Stmts> <e:Elif>
        => rrc(Stmt::Branch(c, i, vec![e], l..r)),
}

Stmt: Rrc<Stmt<'input>> = {
    <If>,
    <l:@L> "repeat" <r:@R> <e:Expr> <b:Stmts> => rrc(Stmt::Repeat(e, b, l..r)),
    <l:@L> "forever" <r:@R> <b:Stmts> => rrc(Stmt::Forever(b, l..r)),
    <l:@L> "until" <r:@R> <e:Expr> <b:Stmts> => rrc(Stmt::Until(e, b, l..r)),
    <l:@L> <n:Name> <r:@R> "=" <e:Expr> ";" => rrc(Stmt::SetVariable(n, e, l..r)),
    <l:@L> <n:Name> <r:@R> "+=" <e:Expr> ";" => rrc(Stmt::ChangeVariable(n, e, l..r)),
    <l:@L> "show" ";" <r:@R> => rrc(Stmt::Block(Block::Show, vec![], l..r)),
    <l:@L> "hide" ";" <r:@R> => rrc(Stmt::Block(Block::Hide, vec![], l..r)),
    "show" <l:@L> <n:Name> <r:@R> ";" => rrc(Stmt::Show(n, l..r)),
    "hide" <l:@L> <n:Name> <r:@R> ";" => rrc(Stmt::Hide(n, l..r)),
    "add" <e:Expr> "to" <l:@L> <n:Name> <r:@R> ";" => rrc(Stmt::ListAdd(n, e, l..r)),
    "delete" <l:@L> <n:Name> <r:@R> "[" <e:Expr> "]" ";" => rrc(Stmt::ListDelete(n, e, l..r)),
    <l:@L> "log" <r:@R> <a:Exprs> ";" => rrc(Stmt::Block(Block::Log, a, l..r)),
    "delete" <l:@L> <n:Name> <r:@R> ";" => rrc(Stmt::ListDeleteAll(n, l..r)),
    "insert" <e:Expr> "at" <i:Expr> "of" <l:@L> <n:Name> <r:@R> ";"
        => rrc(Stmt::ListInsert(n, i, e, l..r)),
    <l:@L> <n:Name> <r:@R> "[" <i:Expr> "]" "=" <e:Expr> ";" => rrc(Stmt::ListReplace(n, i, e, l..r)),
    <l:@L> <n:Name> <r:@R> <a:Exprs> ";" => match Block::from_str(n) {
        Ok(mut b) => {
            match b {
                Block::Clone => match a.len() {
                    1 => {
                        b = Block::CloneSprite;
                    }
                    _ => {}
                }
                Block::Goto => match a.len() {
                    1 => {
                        b = Block::GotoSprite;
                    }
                    _ => {}
                }
                Block::Glide => match a.len() {
                    2 => {
                        b = Block::GlideToSprite;
                    }
                    _ => {}
                }
                Block::Say => match a.len() {
                    2 => {
                        b = Block::SayForSeconds;
                    }
                    _ => {}
                }
                Block::Think => match a.len() {
                    2 => {
                        b = Block::ThinkForSeconds;
                    }
                    _ => {}
                }
                _ => {}
            }
            rrc(Stmt::Block(b, a, l..r))
        },
        Err(_) => rrc(Stmt::Call(n, a, l..r)),
    }
}

Exprs: Exprs<'input> = Comma<Expr>;

Expr: Rrc<Expr<'input>> = {
    #[precedence(level="0")]
    Term,
    #[precedence(level="1")] #[assoc(side="left")]
    <l:@L> <e:Expr> "[" <i:Expr> "]" <r:@R>
        => rrc(Expr::BinaryOp(BinaryOp::Of, e, i, l..r)),
    #[precedence(level="2")] #[assoc(side="right")]
    <l:@L> "-" <e:Expr> <r:@R> => rrc(Expr::UnaryOp(UnaryOp::Minus, e, l..r)),
    <l:@L> "not" <e:Expr> <r:@R> => rrc(Expr::UnaryOp(UnaryOp::Not, e, l..r)),
    <l:@L> "length" <e:Expr> <r:@R> => rrc(Expr::UnaryOp(UnaryOp::Length, e, l..r)),
    <l:@L> "round" <e:Expr> <r:@R> => rrc(Expr::UnaryOp(UnaryOp::Round, e, l..r)),
    <l:@L> "abs" <e:Expr> <r:@R> => rrc(Expr::UnaryOp(UnaryOp::Abs, e, l..r)),
    <l:@L> "floor" <e:Expr> <r:@R> => rrc(Expr::UnaryOp(UnaryOp::Floor, e, l..r)),
    <l:@L> "ceil" <e:Expr> <r:@R> => rrc(Expr::UnaryOp(UnaryOp::Ceil, e, l..r)),
    <l:@L> "sqrt" <e:Expr> <r:@R> => rrc(Expr::UnaryOp(UnaryOp::Sqrt, e, l..r)),
    <l:@L> "sin" <e:Expr> <r:@R> => rrc(Expr::UnaryOp(UnaryOp::Sin, e, l..r)),
    <l:@L> "cos" <e:Expr> <r:@R> => rrc(Expr::UnaryOp(UnaryOp::Cos, e, l..r)),
    <l:@L> "tan" <e:Expr> <r:@R> => rrc(Expr::UnaryOp(UnaryOp::Tan, e, l..r)),
    <l:@L> "asin" <e:Expr> <r:@R> => rrc(Expr::UnaryOp(UnaryOp::Asin, e, l..r)),
    <l:@L> "acos" <e:Expr> <r:@R> => rrc(Expr::UnaryOp(UnaryOp::Acos, e, l..r)),
    <l:@L> "atan" <e:Expr> <r:@R> => rrc(Expr::UnaryOp(UnaryOp::Atan, e, l..r)),
    <l:@L> "ln" <e:Expr> <r:@R> => rrc(Expr::UnaryOp(UnaryOp::Ln, e, l..r)),
    <l:@L> "log" <e:Expr> <r:@R> => rrc(Expr::UnaryOp(UnaryOp::Log, e, l..r)),
    <l:@L> "antiln" <e:Expr> <r:@R> => rrc(Expr::UnaryOp(UnaryOp::AntiLn, e, l..r)),
    <l:@L> "antilog" <e:Expr> <r:@R> => rrc(Expr::UnaryOp(UnaryOp::AntiLog, e, l..r)),
    #[precedence(level="3")] #[assoc(side="left")]
    <l:@L> <le:Expr> "*" <re:Expr> <r:@R> => rrc(Expr::BinaryOp(BinaryOp::Mul, le, re, l..r)),
    <l:@L> <le:Expr> "/" <re:Expr> <r:@R> => rrc(Expr::BinaryOp(BinaryOp::Div, le, re, l..r)),
    <l:@L> <le:Expr> "%" <re:Expr> <r:@R> => rrc(Expr::BinaryOp(BinaryOp::Mod, le, re, l..r)),
    #[precedence(level="4")] #[assoc(side="left")]
    <l:@L> <le:Expr> "+" <re:Expr> <r:@R> => rrc(Expr::BinaryOp(BinaryOp::Add, le, re, l..r)),
    <l:@L> <le:Expr> "-" <re:Expr> <r:@R> => rrc(Expr::BinaryOp(BinaryOp::Sub, le, re, l..r)),
    #[precedence(level="5")] #[assoc(side="left")]
    <l:@L> <le:Expr> "<" <re:Expr> <r:@R> => rrc(Expr::BinaryOp(BinaryOp::Lt, le, re, l..r)),
    <l:@L> <le:Expr> "<=" <re:Expr> <r:@R> => rrc(Expr::BinaryOp(BinaryOp::Le, le, re, l..r)),
    <l:@L> <le:Expr> ">" <re:Expr> <r:@R> => rrc(Expr::BinaryOp(BinaryOp::Gt, le, re, l..r)),
    <l:@L> <le:Expr> ">=" <re:Expr> <r:@R> => rrc(Expr::BinaryOp(BinaryOp::Ge, le, re, l..r)),
    #[precedence(level="6")] #[assoc(side="right")]
    <l:@L> <le:Expr> "&" <re:Expr> <r:@R> => rrc(Expr::BinaryOp(BinaryOp::Join, le, re, l..r)),
    #[precedence(level="7")] #[assoc(side="left")]
    <l:@L> <le:Expr> "in" <re:Expr> <r:@R> => rrc(Expr::BinaryOp(BinaryOp::In, le, re, l..r)),
    <l:@L> <le:Expr> "=" <re:Expr> <r:@R> => rrc(Expr::BinaryOp(BinaryOp::Eq, le, re, l..r)),
    <l:@L> <le:Expr> "!=" <re:Expr> <r:@R> => rrc(Expr::BinaryOp(BinaryOp::Ne, le, re, l..r)),
    #[precedence(level="8")] #[assoc(side="left")]
    <l:@L> <le:Expr> "and" <re:Expr> <r:@R> => rrc(Expr::BinaryOp(BinaryOp::And, le, re, l..r)),
    #[precedence(level="9")] #[assoc(side="left")]
    <l:@L> <le:Expr> "or" <re:Expr> <r:@R> => rrc(Expr::BinaryOp(BinaryOp::Or, le, re, l..r)),
}

Term: Rrc<Expr<'input>> = {
    "(" <Expr> ")",
    <l:@L> <i:Int> <r:@R> => rrc(Expr::Int(serde_json::from_str(i).unwrap(), l..r)),
    <l:@L> <f:Float> <r:@R> => rrc(Expr::Float(serde_json::from_str(f).unwrap(), l..r)),
    <l:@L> <s:ParsedString> <r:@R> => rrc(Expr::String(s, l..r)),
    <l:@L> <h:Hexadecimal> <r:@R> =>
        rrc(Expr::Int(i64::from_str_radix(h.split_at(2).1, 16).unwrap(), l..r)),
    <l:@L> <b:Binary> <r:@R> =>
        rrc(Expr::Int(i64::from_str_radix(b.split_at(2).1, 2).unwrap(), l..r)),
    <l:@L> <o:Octal> <r:@R> =>
        rrc(Expr::Int(i64::from_str_radix(o.split_at(2).1, 8).unwrap(), l..r)),
    <l:@L> <n:Name> <r:@R> => rrc(Expr::Name(n, l..r)),
    <l:@L> <a:ArgumentName> <r:@R> => rrc(Expr::Arg(&a[1..], l..r)),
    <l:@L> <n:Name> <r:@R> "(" <e:Exprs> ")" =>? match Reporter::from_str(n) {
        Ok(rep) => match rep {
            _ => Ok(rrc(Expr::Reporter(rep, e, l..r)))
        }
        Err(_) => Err(ParseError::User {error: ParserError::UnknownReporter(n, l..r)}),
    },
}

Names: Names<'input> = SpannedComma<Name>;
Strings: Strings = SpannedComma<ParsedString>;

ParsedString: Rc<str> = <String> => serde_json::from_str::<String>(<>).unwrap().into();


SpannedComma<T>: Vec<(T, Span)> = {
    <mut v:SpannedComma<T>> "," <l:@L> <e:T> <r:@R> => {
        v.push((e, l..r));
        v
    },
    <l:@L> <e:T> <r:@R> => vec![(e, l..r)],
    => vec![],
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        Some(e) => {
            v.push(e);
            v
        }
        None => v
    }
}

extern {
    type Location = usize;
    type Error = ParserError<'input>;
    enum Token<'input> {
        Comment => Token::Comment(<&'input str>),
        DocComment => Token::DocComment(<&'input str>),
        Name => Token::Name(<&'input str>),
        ArgumentName => Token::ArgumentName(<&'input str>),
        MacroName => Token::MacroName(<&'input str>),
        Int => Token::Int(<&'input str>),
        Hexadecimal => Token::Hexadecimal(<&'input str>),
        Binary => Token::Binary(<&'input str>),
        Octal => Token::Octal(<&'input str>),
        Float => Token::Float(<&'input str>),
        String => Token::String(<&'input str>),
        "costumes" => Token::Costumes,
        "sounds" => Token::Sounds,
        "global" => Token::Global,
        "variables" => Token::Variables,
        "lists" => Token::Lists,
        "def" => Token::Def,
        "nowarp" => Token::NoWarp,
        "on" => Token::On,
        "onflag" => Token::OnFlag,
        "onkey" => Token::OnKey,
        "onclick" => Token::OnClick,
        "onbackdrop" => Token::OnBackdrop,
        "onloudness" => Token::OnLoudness,
        "ontimer" => Token::OnTimer,
        "onclone" => Token::OnClone,
        "macro" => Token::Macro,
        "local" => Token::Local,
        "if" => Token::If,
        "else" => Token::Else,
        "elif" => Token::Elif,
        "until" => Token::Until,
        "forever" => Token::Forever,
        "repeat" => Token::Repeat,
        "," => Token::Comma,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "->" => Token::Arrow,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "=" => Token::Assign,
        "++" => Token::Increment,
        "--" => Token::Decrement,
        "+=" => Token::AssignAdd,
        "-=" => Token::AssignSubtract,
        "*=" => Token::AssignMultiply,
        "/=" => Token::AssignDivide,
        "%=" => Token::AssignModulo,
        "&=" => Token::AssignJoin,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "." => Token::Dot,
        "!=" => Token::Ne,
        "<" => Token::Lt,
        ">" => Token::Gt,
        "<=" => Token::Le,
        ">=" => Token::Ge,
        "not" => Token::Not,
        "and" => Token::And,
        "or" => Token::Or,
        "in" => Token::In,
        "&" => Token::Join,
        "+" => Token::Plus,
        "-" => Token::Subtract,
        "*" => Token::Multiply,
        "/" => Token::Divide,
        "%" => Token::Modulo,
        ";" => Token::Semicolon,
        "length" => Token::Length,
        "round" => Token::Round,
        "abs" => Token::Abs,
        "floor" => Token::Floor,
        "ceil" => Token::Ceil,
        "sqrt" => Token::Sqrt,
        "sin" => Token::Sin,
        "cos" => Token::Cos,
        "tan" => Token::Tan,
        "asin" => Token::Asin,
        "acos" => Token::Acos,
        "atan" => Token::Atan,
        "ln" => Token::Ln,
        "log" => Token::Log,
        "antiln" => Token::Antiln,
        "antilog" => Token::Antilog,
        "show" => Token::Show,
        "hide" => Token::Hide,
        "add" => Token::Add,
        "delete" => Token::Delete,
        "insert" => Token::Insert,
        "at" => Token::At,
        "to" => Token::To,
        "of" => Token::Of,
    }
}
